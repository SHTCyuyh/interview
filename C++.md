# 0421 快手笔试
## `vector` 和 `list`相关：
Vector：
* vector的数据总是存放在堆上， 对象根据定义（有时候栈，有时候堆）
* 向量（vector）中间的插入和删除是非常昂贵的，因为它需要大量的时间来移动所有的元素
* vector支持随机访问
* push_back()时间复杂度 O(1)

List：
* List更适合顺序访问且适合插入删除；
* 支持双向，并为插入和删除操作提供了一种有效的方法。
* List是连续的容器

## inline
* 关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用 `用于实现的关键字`
* 使用inline修饰避免了频繁调用函数对栈内存重复开辟所带来的消耗。
* inline只适合涵数体内代码简单的函数数使用，不能包含复杂的结构控制语句例如while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。

## static(静态成员变量)
```
class Student{
public:
    Student(char *name, int age, float score);
    void show();
public:
    static int m_total;  //静态成员变量
private:
    char *m_name;
    int m_age;
    float m_score;
};
```
静态成员变量 m_total
* static 成员变量属于类，不属于某个具体的对象，即使创建多个对象，也只为 m_total 分配一份内存，所有对象使用的都是这份内存中的数据。当某个对象修改了 m_total，也会影响到其他对象。
* static 成员变量必须在类声明的外部初始化:静态成员变量在初始化时不能再加 static，但必须要有数据类型。
        ```
        int Student::m_total = 0;
        ```
* static 成员变量不占用对象的内存，而是在所有对象之外开辟内存，即使不创建对象也可以访问，static 成员变量和普通的 static 变量类似，都在内存分区中的全局数据区分配内存
* static 成员变量既可以通过对象来访问， 也可以通过类来访问
  
# 5.29 海康威视面试
new 和 malloc 的区别
* 类型安全性：new 和 delete 是 C++ 的操作符，会自动执行对象的构造和析构函数，并保证类型安全。malloc 和 free 是 C 语言的函数，不会执行构造和析构函数，需要手动管理内存。因此，new 和 delete 在类型安全性方面更可靠。
* 内存分配方式：new 操作符使用 C++ 的运算符重载，会根据所需的内存大小自动调用适当的 operator new 函数进行内存分配。而 malloc 函数需要显式指定分配的字节数。因此，new 更方便，不需要显式指定内存大小。
* 内存分配失败处理：new 操作符在内存分配失败时会抛出 std::bad_alloc 异常，可以通过异常处理机制进行处理。而 malloc 函数在内存分配失败时返回 NULL，需要手动检查返回值并处理分配失败的情况。
* 对象的构造和析构函数调用：new 操作符在分配内存后会自动调用对象的构造函数来初始化对象，在使用 delete 释放内存时会自动调用对象的析构函数来进行清理。而 malloc 和 free 不会自动调用构造和析构函数，需要手动管理对象的构造和析构。

double free报错：
* 当发生双重释放（double free）时，报错通常发生在运行时。具体来说，当代码尝试释放已经被释放的内存块时，C++运行时系统会检测到该错误，并触发一次运行时错误。

c++构造函数类别：
* 默认构造函数（Default Constructor）：当没有显式定义构造函数时，编译器会自动生成默认构造函数。默认构造函数没有参数，用于创建对象的实例并进行初始化。如果类定义中没有其他构造函数的定义，那么默认构造函数将被隐式地提供。
* 带参数的构造函数（Parameterized Constructor）：带参数的构造函数接受一个或多个参数，用于在创建对象时进行初始化。通过提供不同的参数组合，可以创建具有不同初始状态的对象。
* 拷贝构造函数（Copy Constructor）：拷贝构造函数用于通过已有对象创建一个新对象，并进行深拷贝（复制对象的内容）。拷贝构造函数的参数是同类型的对象的引用。当使用赋值语句、函数参数传递或函数返回值时，拷贝构造函数会被隐式调用。
* 移动构造函数（Move Constructor）：移动构造函数是C++11引入的新特性，用于在对象间执行资源的移动而不进行深拷贝。移动构造函数通过接受右值引用作为参数，从临时对象或将要销毁的对象中“窃取”资源。
* 转换构造函数（Conversion Constructor）：转换构造函数用于将其他类型的对象隐式转换为当前类的对象。它可以定义为只有一个参数的构造函数，并且该参数可以是不同类型的对象
* 委托构造函数（Delegating Constructor）：委托构造函数是C++11引入的特性，允许一个构造函数调用同一个类的其他构造函数，以避免代码的重复。委托构造函数通过使用成员初始化列表中的冒号语法来委托其他构造函数的初始化工作。

堆和栈的区别
* 堆（Heap）：
    * 堆是动态分配的内存区域，用于存储程序运行期间动态创建的数据。
    * 堆的大小通常比栈大，并且可以动态增长。
    * 堆中的内存由程序员手动分配和释放，使用特定的堆分配函数（如malloc或new）进   * 行分配，使用相应的释放函数（如free或delete）进行释放。
    * 堆中的数据可以在程序的任意位置访问，其生命周期可以长至整个程序运行期间。
    * 在堆中分配的数据不会自动释放，需要手动释放，否则可能会导致内存泄漏。
* 栈（Stack）：
    * 栈是自动分配的内存区域，用于存储函数调用时的局部变量、函数参数和函数调用的上下文信息。
    * 栈的大小通常比堆小，并且固定不变。
    * 栈中的数据由编译器自动管理，不需要程序员手动分配和释放。
    * 栈中的数据的生命周期与其所属的函数调用相关，当函数调用结束时，其在栈上分配的数据会自动被释放。
    * 栈的操作速度比堆快，因为栈的分配和释放都是通过移动指针来完成，非常高效。
* 全局变量和静态变量通常存储在程序的静态数据区，其生命周期从程序启动到程序结束
* 局部变量和函数参数通常存储在栈上，其生命周期与所属的函数调用相关。
* 动态分配的对象（使用new或malloc分配）通常存储在堆上，其生命周期由程序员手动管理，需要显式释放内存。
* 静态对象（如静态类成员）通常存储在静态数据区，其生命周期从程序启动到程序结束。


# 5.31复习
顺序容器的相关复杂度
* Vector：支持快速随机访问，尾部插入和删除元素的代价是较低 常数时间复杂度（O(1)），但在中间或开头插入和删除元素的代价较高，需要移动其他元素，时间复杂度为O(n)。
* List：列表是一个双向链表，支持在任意位置插入和删除元素，但访问元素的代价相对较高，需要遍历链表。在任意位置插入和删除元素的代价是常数时间复杂度（O(1)），因为只需要修改相邻节点的指针，不需要移动其他元素
* Deque：双端队列是一个双向开口的动态数组，支持在头部和尾部进行插入和删除操作，常数时间复杂度（O(1)）。插入和删除元素的代价在两端较低。
* Queue： 列是一种先进先出（FIFO）的数据结构，只支持在队尾插入元素和在队头删除元素。在队尾或栈顶插入和删除元素的代价是常数时间复杂度（O(1)）。
* Stack：栈是一种后进先出（LIFO）的数据结构，只支持在栈顶插入和删除元素。在队尾或栈顶插入和删除元素的代价是常数时间复杂度（O(1)）。
* forward_list：只支持单向遍历，只能从头部到尾部进行迭代，无法反向遍历插入和删除操作比较高效，因为它只需要修改相邻节点的指针，不需要移动其他元素。`没有size()操作`
* array: 需要固定大小（编译时确定），支持赋值拷贝数组，但是内置数组不支持赋值拷贝！但是不支持花括号赋值，支持列表初始化！！！。
* swap(c1,c2)交换c1与c2中的元素。
* assign方法：支持不同顺序容器之间，将右边容器所有元素拷贝到左边。`eg：seq1.assign(seq2.begin(), seq2.end())`